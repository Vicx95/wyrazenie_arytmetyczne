
#include <stdexcept>
#include <sstream>
#include <string>
#include <cmath>

#include "wyrazenie_arytmetyczne.hpp"

using namespace std;
using namespace wyrazenie_arytmetyczne;
std::vector<std::pair<std::string, double> > zmienna::v;
// class liczba
double liczba::oblicz()
{
	return x;
}
//**********************************************************
//##########################################################
//**********************************************************
string liczba::opis()
{
	ostringstream op;
	op << x;
	return op.str();
}
//**********************************************************
//##########################################################
//**********************************************************

// class stala
string stala::opis()
{
	return nazwa;
}
//**********************************************************
//##########################################################
//**********************************************************
// class pi
double pi::oblicz()
{
	return atan(1) * 4;
}
//**********************************************************
//##########################################################
//**********************************************************
double e::oblicz()
{
	return 2.7182;
}
//**********************************************************
//##########################################################
//**********************************************************
double fi::oblicz()
{
	return 1.6180;
}

//**********************************************************
//##########################################################
//**********************************************************
//class zmienna
/*
std::string zmienna::opis()
{
	return nazwa;
}
double zmienna::oblicz()
{
	return 0.00;
}
*/
//**********************************************************
//##########################################################
//**********************************************************

// class operator1arg
operator1arg::operator1arg(wyrazenie *a1) : arg1(a1)
{
	if (a1 == nullptr) throw invalid_argument("pusty argument pierwszy operatora");
}
//**********************************************************
//##########################################################
//**********************************************************
operator1arg::~operator1arg()
{
	delete arg1;
}
//**********************************************************
//##########################################################
//**********************************************************
// class sinus
double sinus::oblicz()
{
	return sin(arg1->oblicz());
}

string sinus::opis()
{
	ostringstream oss;
	oss << "sin(" << arg1->opis() << ")";
	return oss.str();
}
//**********************************************************
//##########################################################
//**********************************************************
string bezwzgl::opis()
{
	ostringstream oss;
	oss << "bezwzgl= " << arg1->opis();
	return oss.str();
}

double bezwzgl::oblicz()
{
	return abs(arg1->oblicz());
}

//**********************************************************
//##########################################################
//**********************************************************
string cosinus::opis()
{
	ostringstream oss;
	oss << "cos(" << arg1->opis() << ")";
	return oss.str();
}

double cosinus::oblicz()
{
	return cos(arg1->oblicz());
}
//**********************************************************
//##########################################################
//**********************************************************
string przeciw::opis()
{
	ostringstream oss;
	oss << "cos(" << arg1->opis() << ")";
	return oss.str();
}

double przeciw::oblicz()
{
	return -(arg1->oblicz());

}

string exp1::opis()
{
	ostringstream oss;
	oss << "exp(" << arg1->opis() << ")";
	return oss.str();
}

double exp1::oblicz()
{
	return exp(arg1->oblicz());

}
//**********************************************************
//##########################################################
//**********************************************************
string odwrot::opis()
{
	ostringstream oss;
	oss << "odwrot(" << arg1->opis() << ")";
	return oss.str();
}

double odwrot::oblicz()
{
	return ((1 / arg1->oblicz()));

}
//**********************************************************
//##########################################################
//**********************************************************
string ln::opis()
{
	ostringstream oss;
	oss << "ln(" << arg1->opis() << ")";
	return oss.str();
}

double ln::oblicz()
{
	if (arg1 <= 0)  throw invalid_argument("liczba logarytmowana musi byc dodatnia");
	else return log(arg1->oblicz());

}

//**********************************************************
//##########################################################
//**********************************************************
// class operator2arg
operator2arg::operator2arg(wyrazenie *a1, wyrazenie *a2) : operator1arg(a1), arg2(a2)
{
	if (a2 == nullptr) throw invalid_argument("pusty argument drugi operatora");
}
//**********************************************************
//##########################################################
//**********************************************************
operator2arg::~operator2arg()
{
	delete arg2;
}
//**********************************************************
//##########################################################
//**********************************************************

// class dodaj


double dodaj::oblicz()
{
	return arg1->oblicz() + arg2->oblicz();

}
//**********************************************************
//##########################################################
//**********************************************************
string dodaj::opis() {
	ostringstream oss;
	oss << "(" + arg1->opis() + " + " + arg2->opis() + ")";
	return oss.str();
}
//**********************************************************
//##########################################################
//**********************************************************

double logarytm::oblicz()
{
	return (log( arg2->oblicz() ) /  log( arg1->oblicz() ) ) ;

}
//**********************************************************
//##########################################################
//**********************************************************
string logarytm::opis()
{
	ostringstream oss;
	oss << "log" + arg1->opis() + " (" + arg2->opis() + ")"; //error
	return oss.str();
}
//**********************************************************
//##########################################################
//**********************************************************
double odejmij::oblicz()
{
	return arg1->oblicz() - arg2->oblicz();

}
//**********************************************************
//##########################################################
//**********************************************************
string odejmij::opis() {
	ostringstream oss;
	oss << "(" + arg1->opis() + " - " + arg2->opis() + ")";
	return oss.str();
}
//**********************************************************
//##########################################################
//**********************************************************
double mnoz::oblicz()
{
	return arg1->oblicz() * arg2->oblicz();

}
//**********************************************************
//##########################################################
//**********************************************************
string mnoz::opis() {
	ostringstream oss;
	oss << "(" + arg1->opis() + " * " + arg2->opis() + ")";
	return oss.str();
}
//**********************************************************
//##########################################################
//**********************************************************

double dziel::oblicz()
{
	if (arg2->oblicz() == 0) throw invalid_argument("NIE MOZNA DZIELIC PRZEZ ZERO!!!");
	return (arg1->oblicz() / arg2->oblicz() );

}
//**********************************************************
//##########################################################
//**********************************************************
string dziel::opis() {
	ostringstream oss;
	oss << "(" + arg1->opis() + " / " + arg2->opis() + ")";
	return oss.str();
}
//**********************************************************
//##########################################################
//**********************************************************

double potega::oblicz()
{
	return pow(arg1->oblicz(), arg2->oblicz());

}
//**********************************************************
//##########################################################
//**********************************************************
string potega::opis() {
	ostringstream oss;
	oss << "(" + arg1->opis() + " ^ " + arg2->opis() + ")";
	return oss.str();
}
//**********************************************************
//##########################################################
